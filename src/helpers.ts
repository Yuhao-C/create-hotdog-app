import { execSync } from 'child_process';
import fs from 'fs-extra';
import path from 'path';
import semver from 'semver';
import { green, cyan, red } from 'chalk';
import prompt, { PromptObject } from 'prompts';
import validateProjectName from 'validate-npm-package-name';

const { log, error } = console;

export const nodeYarnVersionCheck = (): void => {
  if (semver.lt(process.version, '10.0.0')) {
    error(
      red(
        'You are running Node ' +
          process.version +
          '.\n' +
          'create-hotdog-app requires Node 10 or higher. \n' +
          'Please update your version of Node.',
      ),
    );
    process.exit(1);
  }
  try {
    const yarnVer = execSync('yarn --version', {
      encoding: 'utf8',
      stdio: 'pipe',
    });
    if (!semver.satisfies(yarnVer, '1.x')) {
      error(
        red(
          'You are running Yarn ' +
            yarnVer +
            '.\n' +
            'create-hotdog-app requires Yarn 1. \n' +
            'Please update your version of Yarn.',
        ),
      );
      process.exit(1);
    }
  } catch (e) {
    error(red(e.stderr));
    process.exit(1);
  }
};

export const dirNameCheck = (
  dirName: string | undefined,
  programName: string,
): void => {
  if (typeof dirName === 'undefined') {
    error('Please specify the project directory:');
    log(`  ${cyan(programName)} ${green('<project-directory>')}`);
    log();
    log('For example:');
    log(`  ${cyan(programName)} ${green('hotdog-app')}`);
    process.exit(1);
  }
};

export const appNameCheck = (name: string): void => {
  const validationResult = validateProjectName(name);
  if (!validationResult.validForNewPackages) {
    error(
      red(
        `Cannot create a project named ${green(
          `"${name}"`,
        )} because of npm naming restrictions:\n`,
      ),
    );
    [
      ...(validationResult.errors || []),
      ...(validationResult.warnings || []),
    ].forEach(err => {
      error(red(`  * ${err}`));
    });
    error(red('\nPlease choose a different project name.'));
    process.exit(1);
  }
};
// If project only contains files generated by GH, itâ€™s safe.
// Also, if project contains remnant error logs from a previous
// installation, lets remove them now.
export const checkDirSafe = (root: string, dir: string): void => {
  const validFiles = [
    '.DS_Store',
    '.git',
    '.gitattributes',
    '.gitignore',
    '.gitlab-ci.yml',
    '.hg',
    '.hgcheck',
    '.hgignore',
    '.idea',
    '.npmignore',
    '.travis.yml',
    'docs',
    'LICENSE',
    'README.md',
    'mkdocs.yml',
    'Thumbs.db',
  ];
  // These files should be allowed to remain on a failed install, but then
  // silently removed during the next create.
  const errorLogFilePatterns = [
    'npm-debug.log',
    'yarn-error.log',
    'yarn-debug.log',
  ];
  const isErrorLog = (file: string) => {
    return errorLogFilePatterns.some(pattern => file.startsWith(pattern));
  };

  const conflicts = fs
    .readdirSync(root)
    .filter(file => !validFiles.includes(file))
    // Don't treat log files from previous installation as conflicts
    .filter(file => !isErrorLog(file));

  if (conflicts.length > 0) {
    log(`The directory ${green(dir)} contains files that could conflict:`);
    log();
    for (const file of conflicts) {
      try {
        const stats = fs.lstatSync(path.join(root, file));
        if (stats.isDirectory()) {
          log(`  ${cyan(`${file}/`)}`);
        } else {
          log(`  ${file}`);
        }
      } catch (e) {
        log(`  ${file}`);
      }
    }
    log();
    log(
      'Either try using a new directory name, or remove the files listed above.',
    );

    process.exit(1);
  }

  // Remove any log files from a previous installation.
  fs.readdirSync(root).forEach(file => {
    if (isErrorLog(file)) {
      fs.removeSync(path.join(root, file));
    }
  });
};

const packageNameValidator = (name: string) => {
  const validationResult = validateProjectName(name);
  if (!validationResult.validForNewPackages) {
    return 'invalid name';
  }
  return true;
};

type PrmoptFields = 'name' | 'desc' | 'author' | 'url' | 'license';
export const getPackageJsonFields = (
  name: string,
): Promise<prompt.Answers<PrmoptFields>> => {
  interface PromptState {
    aborted: boolean;
  }
  const enableTerminalCursor = () => {
    process.stdout.write('\x1B[?25h');
  };
  const onState = (state: PromptState) => {
    if (state.aborted) {
      // If we don't re-enable the terminal cursor before exiting
      // the program, the cursor will remain hidden
      enableTerminalCursor();
      process.stdout.write('\n');
      process.exit(1);
    }
  };
  const questions: Array<PromptObject<PrmoptFields>> = [
    {
      type: 'text',
      name: 'name',
      message: 'project name:',
      initial: name,
      onState,
      validate: name => packageNameValidator(name),
    },
    { type: 'text', name: 'desc', message: 'description:', onState },
    { type: 'text', name: 'author', message: 'author:', onState },
    { type: 'text', name: 'url', message: 'repository url:', onState },
    {
      type: 'text',
      name: 'license',
      message: 'license:',
      initial: 'MIT',
      format: (val: string) => val.toLocaleUpperCase(),
      onState,
    },
  ];
  return prompt(questions);
};

export const updateReadme = (name: string, dir: string): void => {
  const readmePath = path.join(dir, 'README.md');
  const readme = fs.readFileSync(readmePath).toString().split('\n');
  readme.unshift(`# ${name}\n`);
  fs.writeFileSync(readmePath, readme.join('\n'));
};

export const updateFile = (
  path: string,
  regex: RegExp,
  replacement: string,
): void => {
  const fileStr = fs.readFileSync(path).toString();
  fs.writeFileSync(path, fileStr.replace(regex, replacement));
};

export const updatePackageJson = (
  packageJsonFields: prompt.Answers<PrmoptFields>,
  dir: string,
): void => {
  const { name, desc, author, url, license } = packageJsonFields;
  const packageJsonPath = path.join(dir, 'package.json');
  const packageJsonTemplate = JSON.parse(
    fs.readFileSync(packageJsonPath).toString(),
  );
  packageJsonTemplate.name = name || path.basename(dir);
  packageJsonTemplate.description = desc || '';
  packageJsonTemplate.author = author || '';
  packageJsonTemplate.repository.url = url || '';
  packageJsonTemplate.license = license || '';
  fs.writeFileSync(
    packageJsonPath,
    JSON.stringify(packageJsonTemplate, null, 2),
  );
};

export const printSuccessMessage = (
  name: string,
  dir: string,
  cdPath: string,
): void => {
  log();
  log(`${green('success')} Created ${cyan(name)} at ${cyan(dir)}`);
  log('Inside that directory, you can run several commands:');
  log();
  log(cyan(`  yarn dev`));
  log('    Starts the development server.');
  log();
  log(cyan(`  yarn build`));
  log('    Bundles the app into static files for production.');
  log();
  log(cyan(`  yarn serve`));
  log('    Serve the production code on a local server');
  log();
  log('We suggest that you begin by typing:');
  log();
  log(cyan('  cd'), cdPath);
  console.log(`  ${cyan(`yarn dev`)}`);
  console.log();
  console.log('Happy hacking!');
};

export const parseSnakeCase = (name: string): string => {
  return name.split(/[-_]/).reduce((acc, cur) => {
    const str = cur.trim();
    if (str.length > 0) {
      return `${acc} ${
        str.charAt(0).toLocaleUpperCase() + str.slice(1)
      }`.trim();
    }
    return acc;
  }, '');
};
